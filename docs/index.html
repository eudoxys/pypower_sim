<!doctype html>
    <html>
    <head>
        <title>pypower_sim</title>
        <meta name="expires" content="86400" />
        <link rel="stylesheet" href="qdox.css">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="stylesheet" href="https://www.w3schools.com/w3css/4/w3.css">
    </head>
    <body>

    <!-- Sidebar -->
    <div class="w3-sidebar w3-light-grey w3-bar-block" style="width:180px">
      <center>
        <img src="https://avatars.githubusercontent.com/u/21315775?v=4" height="128px" width="128px"/>
        <br/><a href="https://github.com/eudoxys">Eudoxys Sciences LLC</a>
        <br/><a href="https://github.com/eudoxys"></a>
      </center>
      <title class="w3-bar-item">pypower_sim</title>
      <a href="#main" class="w3-bar-item w3-button">Command Line</a>
      <a href="#python" class="w3-bar-item w3-button">Python Library</a>
      <a href="#package" class="w3-bar-item w3-button">Package Metadata</a>
    </div>

    <!-- Page Content -->
    <div style="margin-left:220px">

    <h1 id="main" class="w3-container">Command Line</h1>

    <p/>


<h2 class="w3-container">pypower_sim</h2>
<p/>
PyPOWER timeseries simulation


<h1 id="python" class="w3-container">Python Library</h1>


<h2 class="w3-container">Class pypower_sim.KML()</h2>
<p/>
KML generator class


<h3 class="w3-container"><code><b>pypower_sim.KML</b>(<b>kmlfile</b>:<i>str</i>, <b>name</b>:<i>str</i>)</code></h3>
<p/>
Start KML file


<h3 class="w3-container"><code><b>KML.add_line</b>(<b>name</b>:<i>str</i>) &rightarrow; <i>None</i></code></h3>
<p/>
Add a line entity
<p/>


<h4 class="w3-container">Arguments</h4>
<p/>
<ul><li><code>name</code>: line name</li>
<li><code>from_position</code>: line starting position</li>
<li><code>to_position</code>: line ending position</li>
<li><code>style</code>: line style</li>
<li><code>data</code>: line data</li>
</None>

</ul>




<h3 class="w3-container"><code><b>KML.add_linestyle</b>(<b>name</b>:<i>str</i>) &rightarrow; <i>None</i></code></h3>
<p/>
Add a line style
<p/>


<h4 class="w3-container">Arguments</h4>
<p/>
<ul><li><code>name</code>: linestyle name</li>
<li><code>color</code>: line color</li>
<li><code>width</code>: line width</li>
<li><code>opacity</code>: line opacity</li>
</None>

</ul>




<h3 class="w3-container"><code><b>KML.add_marker</b>(<b>name</b>:<i>str</i>) &rightarrow; <i>None</i></code></h3>
<p/>
Add a marker entity
<p/>


<h4 class="w3-container">Arguments</h4>
<p/>
<ul><li><code>name</code>: marker name</li>
<li><code>position</code>: marker position</li>
<li><code>style</code>: marker style</li>
<li><code>data</code>: marker data</li>
</None>

</ul>




<h3 class="w3-container"><code><b>KML.add_markerstyle</b>(<b>name</b>:<i>str</i>) &rightarrow; <i>None</i></code></h3>
<p/>
Add a marker style
<p/>


<h4 class="w3-container">Arguments</h4>
<p/>
<ul><li><code>name</code>: markerstyle name</li>
<li><code>icon</code>: icon URL</li>
<li><code>scale</code>: icon size</li>
</None>

</ul>




<h3 class="w3-container"><code><b>KML.close</b>() &rightarrow; <i>None</i></code></h3>
<p/>
Close KML file


<h2 class="w3-container">Class pypower_sim.PPCLI(ArgumentParser)</h2>
<p/>
Main CLI implementation


<h3 class="w3-container"><code><b>pypower_sim.PPCLI</b>()</code></h3>
<p/>
CLI constructor/processor
<p/>


<h4 class="w3-container">Arguments</h4>
<p/>
(none)
<p/>
<h3 class="w3-container">Static Variables</h3>
<p/><code>E_OK = 0</code>
<p/><code>E_SYNTAX = 1</code>


<h2 class="w3-container">Class pypower_sim.PPData()</h2>
<p/>
PyPOWER model data I/O manager


<h3 class="w3-container"><code><b>pypower_sim.PPData</b>()</code></h3>
<p/>
Setup data I/O manager
<p/>


<h4 class="w3-container">Arguments</h4>
<p/>
<ul><li><code>model</code>: pypower model</li>
</None>

</ul>




<h3 class="w3-container"><code><b>PPData.set_input</b>(<b>name</b>:<i>str</i>, <b>column</b>:<i>str</i>, <b>file</b>:<i>str</i>, <b>scale</b>:<i>float</i>, <b>offset</b>:<i>float</i>, <b>mapping</b>:<i>dict</i>) &rightarrow; <i>None</i></code></h3>
<p/>
Set a timeseries input data feed
<p/>


<h4 class="w3-container">Arguments</h4>
<p/>
<ul><li><code>name</code>: data set name (e.g., bus, branch)</li>
<li><code>column</code>: data column name (e.g., "PD")</li>
<li><code>file</code>: file name from which data is input</li>
<li><code>scale</code>: scaling factor to apply to input data</li>
<li><code>offset</code>: offset to apply to the scaled data</li>
<li><code>mapping</code>: maps column names to data rows with weights</li>
</None>

</ul>




<h3 class="w3-container"><code><b>PPData.set_output</b>(<b>name</b>:<i>str</i>, <b>column</b>:<i>str</i>, <b>file</b>:<i>str</i>, <b>scale</b>:<i>float</i>, <b>offset</b>:<i>float</i>, <b>mapping</b>:<i>dict</i>, <b>formatting</b>:<i>str</i>) &rightarrow; <i>None</i></code></h3>
<p/>
Set a timeseries output data feed
<p/>


<h4 class="w3-container">Arguments</h4>
<p/>
<ul><li><code>name</code>: data set name (e.g., bus, branch)</li>
<li><code>column</code>: data column name (e.g., "PD)</li>
<li><code>file</code>: file name to which data is output</li>
<li><code>scale</code>: scaling factor to apply to output data</li>
<li><code>offset</code>: offset to apply to scaled data</li>
<li><code>mapping</code>: maps column names to data rows with weights</li>
<li><code>formatting</code>: formatting of output</li>
</None>

</ul>




<h3 class="w3-container"><code><b>PPData.set_recorder</b>(<b>file</b>:<i>str</i>, <b>name</b>:<i>str</i>, <b>target</b>:<i>list</i>, <b>scale</b>:<i>float</i>, <b>offset</b>:<i>float</i>) &rightarrow; <i>None</i></code></h3>
<p/>
Set a recorder
<p/>


<h4 class="w3-container">Arguments</h4>
<p/>
<ul><li><code>file</code>: file name to which data is output</li>
<li><code>name</code>: output column name</li>
<li><code>target</code>: case keys to value to record (e.g., ["cost"])</li>
<li><code>scale</code>: scaling factor to apply to output data</li>
<li><code>offset</code>: offset to apply to scaled data</li>
<li><code>format</code>: formatting of output</li>
</None>

</ul>




<h2 class="w3-container">Class pypower_sim.PPGIS()</h2>
<p/>
GIS manager class implementation


<h3 class="w3-container"><code><b>pypower_sim.PPGIS</b>(<b>model</b>:<i>PPModel</i>, str | pandas.core.frame.DataFrame)</code></h3>
<p/>
GIS manager constructor
<p/>


<h4 class="w3-container">Arguments</h4>
<p/>
<ul><li><code>model</code>: pypower_sim model object</li>
</None>

</ul>




<h2 class="w3-container">Class pypower_sim.PPGen()</h2>
<p/>
Abstract class for generator data
<p/>


<h4 class="w3-container">Usage</h4>
<p/>
To use this class, implement a derived class in which you set the data, e.g.,
<p/>
<pre>from pypower_sim.ppgen import PPGen
import pandas as pd
class mygendata(PPGen):
    def __init__(self,df:pd.DataFrame):
        self.data = df
        super().init()
</pre>


<h3 class="w3-container"><code><b>pypower_sim.PPGen</b>(<b>source</b>:<i>str</i>, <b>cache</b>:<i>str</i>)</code></h3>
<p/>
Abstract class constructor for generators
<p/>


<h4 class="w3-container">Arguments</h4>
<p/>
<ul><li><code>source</code>: source of data</li>
<li><code>cache</code>: path name to cache</li>
</None>

</ul>




<h3 class="w3-container"><code><b>PPGen.to_gen</b>(<b>case</b>:<i>dict</i>, <b>ignore_bustype</b>:<i>bool</i>, <b>exclude</b>:<i>dict</i>, list[str] | None, <b>converters</b>:<i>dict</i>, str | None) &rightarrow; <i>DataFrame</i></code></h3>
<p/>
Convert generation fleet data to PyPOWER gen data
<p/>


<h4 class="w3-container">Arguments</h4>
<p/>
<ul><li><code>case</code>: pypower case data tables</li>
<li><code>ignore_bustype</code>: flag to disable limiting nearest bus search based on bustype</li>
<li><code>exclude</code>: table of exclusions</li>
<li><code>groupby</code>: data groupings in addition to bus id</li>
<li><code>converters</code>: value converters to apply to data columns before groups</li>
<li><code>index_csv</code>: CSV file to which gen info is written, same order as genrows, index refers back to data rows
</li>
</None>

</ul>




<h4 class="w3-container">Returns</h4>
<p/>
<ul><li><code>pandas.DataFrame</code>: generator cost data</li>
</None>

</ul>




<h3 class="w3-container"><code><b>PPGen.to_gencost</b>(<b>case</b>:<i>dict</i>, pandas.core.frame.DataFrame | None) &rightarrow; <i>DataFrame</i></code></h3>
<p/>
Convert generation fleet data to PyPOWER gencost data
<p/>


<h4 class="w3-container">Arguments</h4>
<p/>
<ul><li><code>case</code>: pypower case data tables</li>
</None>

</ul>




<h4 class="w3-container">Returns</h4>
<p/>
<ul><li><code>pandas.DataFrame</code>: generator cost data</li>
</None>

</ul>




<h3 class="w3-container"><code><b>PPGen.to_kml</b>(<b>filename</b>:<i>str</i>) &rightarrow; <i>None</i></code></h3>
<p/>
Write KML file
<h3 class="w3-container">Static Variables</h3>
<p/><code>valid_columns = {'state': (<class 'str'>, ''), 'county': (<class 'str'>, ''), 'plant_id': (<class 'int'>, None), 'generator_id': (<class 'str'>, ''), 'unit_code': (<class 'str'>, ''), 'plant_name': (<class 'str'>, ''), 'operating_capacity': (<class 'float'>, nan), 'summer_capacity': (<class 'float'>, nan), 'winter_capacity': (<class 'float'>, nan), 'technology': (<class 'str'>, ''), 'fuel': (<class 'str'>, ''), 'gen': (<class 'str'>, ''), 'latitude': (<class 'float'>, nan), 'longitude': (<class 'float'>, nan), 'geohash': (<class 'str'>, '')}</code>
<p/><code>valid_mappings = {'fuel': {'WATER', 'OTHER', 'WASTE', 'OIL', 'GAS', 'SUN', 'NUCLEAR', 'WIND', 'GEO', 'COAL'}, 'gen': {'IC', 'ST', 'NA', 'ES', 'CT', 'HT', 'CC', 'PV', 'WT'}}</code>


<h2 class="w3-container">Class pypower_sim.PPModel()</h2>
<p/>
PyPower Model Access


<h3 class="w3-container"><code><b>pypower_sim.PPModel</b>(<b>name</b>:<i>str</i>, <b>version</b>:<i>int</i>, <b>mvabase</b>:<i>float</i>, <b>case</b>:<i>Union</i>)</code></h3>
<p/>
Create PyPower case data
<p/>


<h4 class="w3-container">Arguments</h4>
<p/>
<ul><li><code>name</code>: name of the case</li>
<li><code>version</code>: case version number</li>
<li><code>mvabase</code>: MVA base value</li>
<li><code>case</code>: case data</li>
</None>

</ul>




<h3 class="w3-container"><code><b>PPModel.branch</b>() &rightarrow; <i>array</i></code></h3>
<p/>
Create branch data
<p/>


<h4 class="w3-container">Arguments</h4>
<p/>
<ul><li><code>kwargs</code>: merged branch and transformer data (see <code>pypower.idx_brch</code> fordetails)
</li>
</None>

</ul>




<h4 class="w3-container">Returns</h4>
<p/>
<ul><li><code>numpy.array</code>: bus data</li>
</None>

</ul>




<h3 class="w3-container"><code><b>PPModel.bus</b>() &rightarrow; <i>array</i></code></h3>
<p/>
Create bus data
<p/>


<h4 class="w3-container">Arguments</h4>
<p/>
<ul><li><code>kwargs</code>: merged bus, load, and shunt data (see <code>pypower.idx_bus</code> fordetails)
</li>
</None>

</ul>




<h4 class="w3-container">Returns</h4>
<p/>
<ul><li><code>numpy.array</code>: bus data</li>
</None>

</ul>




<h3 class="w3-container"><code><b>PPModel.dcline</b>() &rightarrow; <i>array</i></code></h3>
<p/>
Create dcline data
<p/>


<h4 class="w3-container">Arguments</h4>
<p/>
<ul><li><code>kwargs</code>: dcline data (see <code>pypower.idx_dcline</code> for details)</li>
</None>

</ul>




<h4 class="w3-container">Returns</h4>
<p/>
<ul><li><code>numpy.array</code>: dcline data</li>
</None>

</ul>




<h3 class="w3-container"><code><b>PPModel.dclinecost</b>() &rightarrow; <i>array</i></code></h3>
<p/>
Create dclinecost data
<p/>


<h4 class="w3-container">Arguments</h4>
<p/>
<ul><li><code>kwargs</code>: dclinecost data (see <code>pypower.idx_cost</code> for details)</li>
</None>

</ul>




<h4 class="w3-container">Returns</h4>
<p/>
<ul><li><code>numpy.array</code>: cost data</li>
</None>

</ul>




<h3 class="w3-container"><code><b>PPModel.from_dict</b>(<b>data</b>:<i>dict</i>) &rightarrow; <i>None</i></code></h3>
<p/>
Convert dict to model
<p/>
- <code>data</code>: source data
<p/>


<h3 class="w3-container"><code><b>PPModel.from_json</b>() &rightarrow; <i>None</i></code></h3>
<p/>
Convert model from JSON


<h3 class="w3-container"><code><b>PPModel.gen</b>() &rightarrow; <i>array</i></code></h3>
<p/>
Create gen data
<p/>


<h4 class="w3-container">Arguments</h4>
<p/>
<ul><li><code>kwargs</code>: generation data (see <code>pypower.idx_gen</code> for details)</li>
</None>

</ul>




<h4 class="w3-container">Returns</h4>
<p/>
<ul><li><code>numpy.array</code>: gen data</li>
</None>

</ul>




<h3 class="w3-container"><code><b>PPModel.gencost</b>() &rightarrow; <i>array</i></code></h3>
<p/>
Create gencost data
<p/>


<h4 class="w3-container">Arguments</h4>
<p/>
<ul><li><code>kwargs</code>: generation data (see <code>pypower.idx_gen</code> for details)</li>
</None>

</ul>




<h4 class="w3-container">Returns</h4>
<p/>
<ul><li><code>numpy.array</code>: cost data</li>
</None>

</ul>




<h3 class="w3-container"><code><b>PPModel.get_bus</b>(int | None, str | None) &rightarrow; <i>DataFrame</i></code></h3>
<p/>
Get data for all load busses
<p/>


<h4 class="w3-container">Arguments</h4>
<p/>
<ul><li><code>bustype</code>: bus type of get (i.e., <code>idx_bus.PQ</code>, <code>idx_bus.PV</code>, <code>idx_bus.REF</code>)</li>
<li><code>index</code>: index to use (merge with GIS data if index in GIS columns)</li>
</None>

</ul>




<h4 class="w3-container">Returns</h4>
<p/>
<ul><li><code>pandas.DataFrame</code>: bus data</li>
</None>

</ul>




<h3 class="w3-container"><code><b>PPModel.get_data</b>() &rightarrow; <i>DataFrame</i></code></h3>
<p/>
Get data table with data types
<p/>


<h4 class="w3-container">Arguments</h4>
<p/>
<ul><li><code>name</code>: name of case data to return (e.g., "bus","branch","gis", etc.)</li>
</None>

</ul>




<h4 class="w3-container">Returns</h4>
<p/>
<ul><li><code>pandas.DataFrame</code>: case data requested with data types (see <code>types_idx</code>)</li>
</None>

</ul>




<h3 class="w3-container"><code><b>PPModel.get_gis</b>() &rightarrow; <i>DataFrame</i></code></h3>
<p/>
Get indexed GIS data
<p/>


<h4 class="w3-container">Returns</h4>
<p/>
<ul><li><code>pandas.DataFrame</code>: case GIS data (no index, sorted by row number)</li>
</None>

</ul>




<h3 class="w3-container"><code><b>PPModel.get_graph</b>(<b>level</b>:<i>str</i>, <b>nodes</b>:<i>str</i>) &rightarrow; <i>tuple</i></code></h3>
<p/>
Get network graphs
<p/>


<h4 class="w3-container">Arguments</h4>
<p/>
<ul><li><code>level</code>: "BUS","NODE","ZONE","AREA"</li>
<li><code>nodes</code>: return node type (None, "nearest", "centroid")</li>
</None>

</ul>




<h4 class="w3-container">Returns</h4>
<p/>
<ul><li><code>links</code>: list of link tuples indexes into bus data in order of branch</li>
</None>

</ul>


data
<p/>


<h3 class="w3-container"><code><b>PPModel.get_header</b>(<b>name</b>:<i>str</i>, <b>ignore</b>:<i>list</i>) &rightarrow; <i>list</i></code></h3>
<p/>
Convert idx data to a header list
<p/>


<h4 class="w3-container">Arguments</h4>
<p/>
<ul><li><code>idx</code>: module containing index values</li>
<li><code>ignore</code>: list of index values to ignore</li>
</None>

</ul>




<h4 class="w3-container">Returns</h4>
<p/>
list[str]: ordered list of data array column header names
<p/>


<h3 class="w3-container"><code><b>PPModel.get_info</b>() &rightarrow; <i>dict</i></code></h3>
<p/>
Get model information
<p/>


<h4 class="w3-container">Returns</h4>
<p/>
<ul><li><code>dict</code>: table of model information</li>
</None>

</ul>




<h3 class="w3-container"><code><b>PPModel.get_nodes</b>(pandas.core.frame.DataFrame | None) &rightarrow; <i>dict</i></code></h3>
<p/>
Get a dictionary of nodes and their busses
<p/>


<h4 class="w3-container">Arguments</h4>
<p/>
<ul><li><code>data</code>: dataframe from use ("gis" if None)</li>
</None>

</ul>




<h4 class="w3-container">Returns</h4>
<p/>
<ul><li><code>dict</code>: table of nodes and bus ids</li>
</None>

</ul>




<h3 class="w3-container"><code><b>PPModel.load</b>(_io.StringIO | str | None) &rightarrow; <i>None</i></code></h3>
<p/>
Load the model from a file
<p/>


<h4 class="w3-container">Arguments</h4>
<p/>
<ul><li><code>file</code>: file handle, name, or None for stdin</li>
</None>

</ul>




<h3 class="w3-container"><code><b>PPModel.print</b>() &rightarrow; <i>None</i></code></h3>
<p/>
Print case data


<h3 class="w3-container"><code><b>PPModel.save</b>(_io.StringIO | str | None) &rightarrow; <i>str | None</i></code></h3>
<p/>
Save the model to a file
<p/>


<h4 class="w3-container">Arguments</h4>
<p/>
<ul><li><code>file</code>: file handle, name, or None to return data</li>
</None>

</ul>




<h3 class="w3-container"><code><b>PPModel.save_case</b>(<b>file</b>:<i>StringIO</i>) &rightarrow; <i>None</i></code></h3>
<p/>
Save the case data to a file
<p/>


<h4 class="w3-container">Arguments</h4>
<p/>
<ul><li><code>file</code>: file handle to which case data is saved</li>
<li><code>precision</code>: float rounding precision</li>
</None>

</ul>




<h3 class="w3-container"><code><b>PPModel.save_kml</b>(<b>filename</b>:<i>str</i>, <b>use_geocode</b>:<i>bool</i>) &rightarrow; <i>None</i></code></h3>
<p/>
Generate KML output
<p/>


<h4 class="w3-container">Arguments</h4>
<p/>
<ul><li><code>filename</code>: KML filename of output</li>
<li><code>use_geocode</code>: marker names are geocode instead of bus id</li>
</None>

</ul>




<h3 class="w3-container"><code><b>PPModel.set_case</b>(<b>case</b>:<i>dict</i>) &rightarrow; <i>Self</i></code></h3>
<p/>
Set the case data
<p/>


<h4 class="w3-container">Arguments</h4>
<p/>
<ul><li><code>case</code>: case data to use</li>
</None>

</ul>




<h4 class="w3-container">Returns</h4>
<p/>
<ul><li><code>self</code>: the model with the newly set case data</li>
</None>

</ul>




<h3 class="w3-container"><code><b>PPModel.to_dict</b>() &rightarrow; <i>dict</i></code></h3>
<p/>
Convert model to a dict


<h3 class="w3-container"><code><b>PPModel.to_json</b>() &rightarrow; <i>str | None</i></code></h3>
<p/>
Convert model to JSON
<p/>


<h4 class="w3-container">Arguments</h4>
<p/>
<ul><li><code>*args</code>: see json.dump()</li>
<li><code>**kwargs</code>: see json.dump()</li>
</None>

</ul>




<h4 class="w3-container">Returns</h4>
<p/>
<ul><li><code>str</code>: JSON data if no <code>fh</code> is specified</li>
<li>None: if <code>fh</code> is specified</li>
</None>

</ul>


<h3 class="w3-container">Static Variables</h3>
<p/><code>branch_optional = ['PF', 'PT', 'QF', 'QT', 'MU_SF', 'MU_ST', 'MU_ANGMIN', 'MU_ANGMAX']</code>
<p/><code>bus_optional = ['LAM_P', 'LAM_Q', 'MU_VMIN', 'MU_VMAX']</code>
<p/><code>dcline_optional = ['MU_PMIN', 'MU_PMAX', 'MU_QMINF', 'MU_QMAXF', 'MU_QMINT', 'MU_QMAXT']</code>
<p/><code>gen_optional = ['MU_PMAX', 'MU_PMIN', 'MU_QMAX', 'MU_QMIN']</code>
<p/><code>standard_idx = {'bus': ['PQ', 'PV', 'REF', 'NONE'], 'branch': [], 'gen': [], 'gencost': ['PW_LINEAR', 'POLYNOMIAL'], 'dcline': [], 'dclinecost': ['PW_LINEAR', 'POLYNOMIAL'], 'gis': []}</code>
<p/><code>types_idx = {'bus': {'BUS_I': <class 'int'>, 'BUS_TYPE': <class 'int'>, 'BUS_AREA': <class 'int'>, 'ZONE': <class 'int'>}, 'branch': {'F_BUS': <class 'int'>, 'T_BUS': <class 'int'>, 'BR_STATUS': <class 'int'>}, 'gen': {'GEN_BUS': <class 'int'>, 'GEN_STATUS': <class 'int'>}, 'gencost': {'MODEL': <class 'int'>, 'NCOST': <class 'int'>}, 'dcline': {'F_BUS': <class 'int'>, 'T_BUS': <class 'int'>, 'BR_STATUS': <class 'int'>}, 'dclinecost': {'MODEL': <class 'int'>, 'NCOST': <class 'int'>}, 'gis': {'BUS_I': <class 'int'>, 'GEOHASH': <class 'str'>, 'NAME': <class 'str'>}}</code>


<h2 class="w3-container">Class pypower_sim.PPPlots()</h2>
<p/>
Plot creation class implementation


<h3 class="w3-container"><code><b>pypower_sim.PPPlots</b>(<b>model</b>:<i>PPModel</i>)</code></h3>
<p/>
Plot creator constructor
<p/>


<h4 class="w3-container">Arguments</h4>
<p/>
<ul><li><code>model</code>: pypower_sim model</li>
</None>

</ul>




<h3 class="w3-container"><code><b>PPPlots.generation</b>(<b>figsize</b>:<i>tuple</i>) &rightarrow; <i>matplotlib.pyplot.figure</i></code></h3>
<p/>
Generate generation profile
<p/>


<h4 class="w3-container">Arguments</h4>
<p/>
<ul><li><code>figsize</code>: figure dimensions</li>
</None>

</ul>




<h4 class="w3-container">Returns</h4>
<p/>
<ul><li><code>matplotlib.pyplot.figure</code>: voltage profile figure</li>
</None>

</ul>




<h3 class="w3-container"><code><b>PPPlots.load</b>(<b>figsize</b>:<i>tuple</i>) &rightarrow; <i>matplotlib.pyplot.figure</i></code></h3>
<p/>
Generate load profile
<p/>


<h4 class="w3-container">Arguments</h4>
<p/>
<ul><li><code>figsize</code>: figure dimensions</li>
</None>

</ul>




<h4 class="w3-container">Returns</h4>
<p/>
<ul><li><code>matplotlib.pyplot.figure</code>: voltage profile figure</li>
</None>

</ul>




<h3 class="w3-container"><code><b>PPPlots.voltage</b>(<b>figsize</b>:<i>tuple</i>) &rightarrow; <i>matplotlib.pyplot.figure</i></code></h3>
<p/>
Generate voltage profile
<p/>


<h4 class="w3-container">Arguments</h4>
<p/>
<ul><li><code>figsize</code>: figure dimensions</li>
</None>

</ul>




<h4 class="w3-container">Returns</h4>
<p/>
<ul><li><code>matplotlib.pyplot.figure</code>: voltage profile figure</li>
</None>

</ul>


<h3 class="w3-container">Static Variables</h3>
<p/><code>figsize = (15, 8)</code>


<h2 class="w3-container">Class pypower_sim.PPSolver()</h2>
<p/>
PyPOWER solver implementation


<h3 class="w3-container"><code><b>pypower_sim.PPSolver</b>()</code></h3>
<p/>
PyPOWER model solver


<h3 class="w3-container"><code><b>PPSolver.run_timeseries</b>(<b>progress</b>:<i>Callable</i>, <b>call_on_fail</b>:<i>Callable</i>, <b>stop_on_fail</b>:<i>bool</i>, <b>stop_test</b>:<i>Callable</i>, <b>use_acopf</b>:<i>bool</i>) &rightarrow; <i>str | list[str] | None</i></code></h3>
<p/>
Run a timeseries simulation
<p/>


<h4 class="w3-container">Arguments</h4>
<p/>
<i>args, </i>*kwargs: See pandas.date_range()
<p/>
<ul><li><code>progress</code>: set a progress callback function</li>
<li><code>call_on_fail</code>: set a call-on-fail function</li>
<li><code>stop_on_fail</code>: enable stop-on-fail condition</li>
<li><code>stop_test</code>: set a stop test call back function</li>
<li><code>use_acopf</code>: enable use of AC OPF instead of DC OPF</li>
</None>

</ul>




<h4 class="w3-container">Returns</h4>
<p/>
<ul><li><code>None</code>: No errors to report</li>
<li><code>str</code>: Error message (when stop_on_fail is True)</li>
<li><code>list[str]</code>: Error messages (when stop_on_fail is False)</li>
</None>

</ul>




<h3 class="w3-container"><code><b>PPSolver.solve_opf</b>(<b>use_acopf</b>:<i>bool</i>, <b>update</b>:<i>str</i>, <b>with_result</b>:<i>bool</i>) &rightarrow; <i>[<class 'bool'>, <class 'dict'>]</i></code></h3>
<p/>
Solve the optimal powerflow problem
<p/>


<h4 class="w3-container">Arguments</h4>
<p/>
<ul><li><code>use_acopf</code>: enable AC OPF solution</li>
<li><code>update</code>: when update of model case data ('always','success','failure')</li>
<li><code>with_result</code>: include result in return value</li>
</None>

</ul>




<h4 class="w3-container">Returns</h4>
<p/>
<ul><li><code>bool</code>: True on success, False on failure</li>
<li><code>dict</code>: result (if with_result is True)</li>
</None>

</ul>




<h3 class="w3-container"><code><b>PPSolver.solve_pf</b>(<b>update</b>:<i>str</i>, <b>with_result</b>:<i>bool</i>) &rightarrow; <i>[<class 'bool'>, <class 'dict'>]</i></code></h3>
<p/>
Solve the powerflow problem
<p/>


<h4 class="w3-container">Arguments</h4>
<p/>
<ul><li><code>update</code>: when to update of model case data ('always','success','failure')</li>
<li><code>with_result</code>: include result in return value</li>
</None>

</ul>




<h4 class="w3-container">Returns</h4>
<p/>
<ul><li><code>bool</code>: True on success, False on failure</li>
<li><code>dict</code>: result (if with_result is True)</li>
</None>

</ul>




<h3 class="w3-container"><code><b>PPSolver.update_inputs</b>(<b>t</b>:<i>datetime</i>) &rightarrow; <i>int</i></code></h3>
<p/>
Synchronize inputs with the current date/time
<p/>


<h4 class="w3-container">Arguments</h4>
<p/>
<ul><li><code>t</code>: the current date/time</li>
</None>

</ul>




<h3 class="w3-container"><code><b>PPSolver.update_outputs</b>(<b>t</b>:<i>datetime</i>, <b>ts_format</b>:<i>str</i>) &rightarrow; <i>int</i></code></h3>
<p/>
Synchronize outputs to the current date/time
<p/>


<h4 class="w3-container">Arguments</h4>
<p/>
<ul><li><code>t</code>: the current date/time</li>
<li><code>ts_format</code>: timestamp format</li>
</None>

</ul>




<h2 class="w3-container">Class pypower_sim.PypowerModelEncoder(JSONEncoder)</h2>
<p/>
Implements pypower_sim data encoder for JSON


<h3 class="w3-container"><code><b>pypower_sim.PypowerModelEncoder</b>()</code></h3>
<p/>
Constructor for JSONEncoder, with sensible defaults.
<p/>
If skipkeys is false, then it is a TypeError to attempt
encoding of keys that are not str, int, float, bool or None.
If skipkeys is True, such items are simply skipped.
<p/>
If ensure_ascii is true, the output is guaranteed to be str
objects with all incoming non-ASCII characters escaped.  If
ensure_ascii is false, the output can contain non-ASCII characters.
<p/>
If check_circular is true, then lists, dicts, and custom encoded
objects will be checked for circular references during encoding to
prevent an infinite recursion (which would cause an RecursionError).
Otherwise, no such check takes place.
<p/>
If allow_nan is true, then NaN, Infinity, and -Infinity will be
encoded as such.  This behavior is not JSON specification compliant,
but is consistent with most JavaScript based encoders and decoders.
Otherwise, it will be a ValueError to encode such floats.
<p/>
If sort_keys is true, then the output of dictionaries will be
sorted by key; this is useful for regression tests to ensure
that JSON serializations can be compared on a day-to-day basis.
<p/>
If indent is a non-negative integer, then JSON array
elements and object members will be pretty-printed with that
indent level.  An indent level of 0 will only insert newlines.
None is the most compact representation.
<p/>
If specified, separators should be an (item_separator, key_separator)
tuple.  The default is (', ', ': ') if <i>indent</i> is `None` and
(',', ': ') otherwise.  To get the most compact JSON representation,
you should specify (',', ':') to eliminate whitespace.
<p/>
If specified, default is a function that gets called for objects
that can't otherwise be serialized.  It should return a JSON encodable
version of the object or raise a `TypeError`.
<p/>
<p/>


<h2 id="python" class="w3-container">Module Functions</h2>


<h3 class="w3-container"><code><b>PypowerModelDecoder</b>() &rightarrow; <i>Any</i></code></h3>
<p/>
Convert JSON data back to pypower_sim data
<p/>


<h4 class="w3-container">Arguments</h4>
<p/>
<ul><li><code>data</code>: JSON data to convert back to pypower_sim object</li>
</None>

</ul>




<h4 class="w3-container">Returns</h4>
<p/>
<ul><li><code>varies</code>: pypower_sim object</li>
</None>

</ul>




<h3 class="w3-container"><code><b>main</b>() &rightarrow; <i>None</i></code></h3>
<p/>
Main command line processor


<h1 id="package" class="w3-container">Package Metadata</h1>
<p/>
<table class="w3-container">
<tr><th><nobr>Name</nobr></th><td>:</td><td>pypower_sim</td></tr>
<tr><th><nobr>Version</nobr></th><td>:</td><td>0.0.0</td></tr>
<tr><th><nobr>Authors</nobr></th><td>:</td><td>David P. Chassin</td></tr>
<tr><th><nobr>Maintainers</nobr></th><td>:</td><td>David P. Chassin <dpchassin@gmail.com></td></tr>
<tr><th><nobr>Description</nobr></th><td>:</td><td>PyPOWER time-series simulator</td></tr>
<tr><th><nobr>Requires-Python</nobr></th><td>:</td><td>>=3.10</td></tr>
<tr><th><nobr>Keywords</nobr></th><td>:</td><td>eudoxys<br/>pypower<br/>simulation<br/>quasi-steady<br/>timeseries</td></tr>
<tr><th><nobr>License</nobr></th><td>:</td><td>MIT</td></tr>
<tr><th><nobr>Classifiers</nobr></th><td>:</td><td>Programming Language :: Python :: 3</td></tr>
<tr><th><nobr>Dependencies</nobr></th><td>:</td><td>None</td></tr>
<tr><th><nobr>Scripts</nobr></th><td>:</td><td><code>ppsim</code> &rightarrow; <code>main()</code></td></tr>
<tr><th><nobr>Urls</nobr></th><td>:</td><td>Homepage = <a href="https://github.com/eudoxys/pypower_sim" target="_tab">https://github.com/eudoxys/pypower_sim</a><br/>Documentation = <a href="https://www.eudoxys.com/pypower_sim" target="_tab">https://www.eudoxys.com/pypower_sim</a><br/>Repository = <a href="https://github.com/eudoxys/pypower_sim.git" target="_tab">https://github.com/eudoxys/pypower_sim.git</a><br/>Issues = <a href="https://github.com/eudoxys/pypower_sim/issues" target="_tab">https://github.com/eudoxys/pypower_sim/issues</a></td></tr>
</table>


<hr/><p/><cite>Copyright &copy; 2025 Eudoxys Sciences LLC</body>
            </html>
